local druid = require("druid.druid")
local sprite_style = require("druid.styles.sprites.style")
local monarch = require "monarch.monarch"

require "main.scripts.player_data"

function remove_user(player_index)
	
	local del_user = load_users()
	table.remove(del_user, player_index)
	save_data(del_user)	
end 


function show_buttons(players) 
	local gui_body = gui.get_node("body_" .. players )
	gui.set_enabled(gui_body, true)
end 


function clear_buttons(self)
	
	for player, data in pairs(players) do
		local gui_body = gui.get_node("body_" .. data)
		--print(gui_body)
		gui.delete_node(gui_body)
	end 

end


local function okay_callback(self)
    num_active_players = 0 
	for k, v in pairs(self.active_players) do 
		num_active_players = num_active_players + 1
	end
	if (num_active_players < 2) 
	then
		gui.set_text(self.select_player_text, "2 Players are required to start.")
	elseif (num_active_players > 4 )
	then 
		gui.set_text(self.select_player_text, "Only 4 people can play at a time.")
	else
	    save_active_players(self.active_players)
		msg.post("/Main_menu#monarch", "enable start button")
		monarch.back()
		print(self.active_players)
	end
end

local function cancel_callback(self)
	
	monarch.back()   
	--players = load_users()
end
	
local function select_player(self, button, player_name)
	-- loop though players to check if we already clicked it
	for index, value in ipairs(self.active_players) do
		if value == player_name then
			print("true")
			gui.play_flipbook(button.node, hash("Button_released"))
			table.remove(self.active_players,index)
			return
		end
	end
    -- add selected player 	
	gui.play_flipbook(button.node, hash("Button_Pressed"))
	table.insert(self.active_players, player_name)
	 
end 

local function remove_dynamic_node(self, button, shift_policy)
	gui.delete_node(button.node)

	self.druid:remove(button)
	local index = self.grid_dynamic_grid:get_index_by_node(button.node)
	self.grid_dynamic_grid:remove(index, shift_policy)
	for i = 1, #self.dynamic_node_buttons do
		if self.dynamic_node_buttons[i] == button then
			table.remove(self.dynamic_node_buttons, i)
			break
		end
	end
end

local function add_node_dynamic(self, index, playername, is_shift_left)
	local node = gui.clone_tree(self.prefab_dynamic)
	--gui.set_color(node[hash("remove_user_button/buttonBody")], vmath.vector4(31,31,31))
	gui.set_enabled(node[hash("remove_user_button/buttonBody")], true)
	gui.set_size(node[hash("remove_user_button/buttonBody")], vmath.vector3(450, 85, 0))
	gui.set_text(node[hash("remove_user_button/text")], playername)
	local player_index = get_player_index(playername)
	self.grid_dynamic_grid:add(node[hash("remove_user_button/buttonBody")], index, is_shift_left)

	local button = self.druid:new_button(node[hash("remove_user_button/buttonBody")], function(_, params, button)
		--remove_dynamic_node(self, button)
		--remove_user(player_index)
		  select_player(self, button, playername)
	end)
	button.on_long_click:subscribe(function()
		remove_user(player_index)
		remove_dynamic_node(self, button)
	end)
	button:set_click_zone(self.grid_dynamic_scroll.view_node)
	table.insert(self.dynamic_node_buttons, button)
end


local function init_dynamic_grid(self)
	-- Vertical horizontal grid
	players = load_users()
	self.dynamic_node_buttons = {}
	--self.dynamic_node_hor_buttons = {}

	self.prefab_dynamic = gui.get_node("remove_user_button/buttonBody")
--	self.prefab_dynamic = gui.get_node("button_template")
	gui.set_enabled(self.prefab_dynamic, false)

	-- for i = 1, 5 do
	for i, data in pairs(players) do
		add_node_dynamic(self, i, data)
	end
	
end


function init(self) 
	self.druid = druid.new(self)
	self.active_players = {} 
	self.removeuserpromptblock = gui.get_node("Select_Player_prompt_body")
	self.select_player_text = gui.get_node("Select_Player_prompt_diag")
	self.removeuserpromptinput = gui.get_node("Select_Player_prompt_input")
	self.removeuserpromptbtnok = gui.get_node("remove_user_prompt_buttonokay/buttonBody")
	self.removeuserpromptbtncancel = gui.get_node("remove_user_prompt_button_cancel/buttonBody")
	--self.playerbox = gui.get_node("players_box")
	
	-- gui.set_enabled(self.removeuserpromptblock, false)
	-- gui.set_enabled(self.removeuserpromptdiag, false)
	-- gui.set_enabled(self.removeuserpromptinput, false)
	-- gui.set_enabled(self.removeuserpromptbtnok, false)
	-- gui.set_enabled(self.removeuserpromptbtncancel, false)
	self.druid:new_button("remove_user_prompt_buttonokay/buttonBody", okay_callback)
	self.druid:new_button("remove_user_prompt_button_cancel/buttonBody", cancel_callback)
	-- self.removed_buttons = {} 
	-- self.buttons = {}
	self.grid_dynamic_grid = self.druid:new_dynamic_grid("players_box")
	--:set_position_function(simple_animate)
	self.grid_dynamic_scroll = self.druid:new_scroll("players_box", "remove_user_button/buttonBody")
	:set_horizontal_scroll(false)
	:bind_grid(self.grid_dynamic_grid)

	--init_dynamic_grid(self)
	init_dynamic_grid(self)

	
	end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	self.druid:final()
end


function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
	if message_id == hash("Show") then 
		gui.set_enabled(self.removeuserpromptblock, true)
		gui.set_enabled(self.removeuserpromptdiag, true)
		gui.set_enabled(self.removeuserpromptinput, true)
		gui.set_enabled(self.removeuserpromptbtnok, true)
		gui.set_enabled(self.removeuserpromptbtncancel, true)
		msg.post(".", "acquire_input_focus")
		
	
	elseif message_id == hash("Hide") then 
		gui.set_enabled(self.removeuserpromptblock, false)
		gui.set_enabled(self.removeuserpromptdiag, false)
		gui.set_enabled(self.removeuserpromptinput, false)
		gui.set_enabled(self.removeuserpromptbtnok, false)
		gui.set_enabled(self.removeuserpromptbtncancel, false)
		
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	   return self.druid:on_input(action_id, action)
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
