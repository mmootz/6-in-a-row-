local score = 0

local monarch = require "monarch.monarch"

require "main.scripts.player_data"

local druid = require("druid.druid")

local function add_score(score,num)	  
	total = score + num
	return total 
end 


local function button1_callback(self)
	self.score = add_score(self.score,2)
	gui.set_text(self.score_node, tostring(self.score))
end

local function button2_callback(self)
	self.score = add_score(self.score,3)
	gui.set_text(self.score_node, tostring(self.score))
end 

local function button4_callback(self)
	self.score = add_score(self.score,4)
	gui.set_text(self.score_node, tostring(self.score))
end 

local function button5_callback(self)
	self.score = add_score(self.score,5)
	gui.set_text(self.score_node, tostring(self.score))
end 

local function button12_callback(self)
	self.score = add_score(self.score,12)
	gui.play_particlefx(self.firework_red)
	gui.play_particlefx(self.firework_blue)
	gui.play_particlefx(self.firework_green) 
	gui.play_particlefx(self.firework_yellow)
	gui.play_particlefx(self.firework_orange)
	gui.play_particlefx(self.firework_purple) 
	gui.set_text(self.score_node, tostring(self.score))
end 

local function score_text_menu(self) 
	--stats_db = load_stats()
	local players = load_active_players()

	for key, value in pairs(players) do 
        
		local score = get_score(score_db ,value , 0)
		print("player: " .. value .. "Score: " .. score )
	end 
	monarch.show("score_popup")
end 


local function okay_callback(self)
	-- load players
	-- get current user from gui 
	-- Find out who is next player
	-- if last player end round and start again
	-- add the score to the table 

	players = load_active_players()
	player_size = 0 
	player_name = gui.get_text(self.username)

	-- get size of table 
	for _ in pairs(players) do player_size = player_size + 1 end
	-- find index 
	for k, v in next, players do
		if v == player_name then 
			match = k     
		end  
	end
	
	if match == player_size then 
		next_player_name = 1
		
		gui.set_text(self.round_number_menu, "Round:" .. tostring(self.round_num))
		score_db = save_score(score_db, gui.get_text(self.username), self.round_num,gui.get_text(self.score_node) , false)
		-- make new table on last user 
		self.round_num = self.round_num + 1 
		score_db = save_score(score_db, gui.get_text(self.username), self.round_num,gui.get_text(self.score_node) , true)
		--print_r(score_db)		
	else
		next_player_name = next(players,match)
		score_db = save_score(score_db, gui.get_text(self.username), self.round_num,gui.get_text(self.score_node) , false)
		--print_r(score_db)
	end 
	gui.set_text(self.username, players[next_player_name])
	player_score = get_score(score_db,players[next_player_name],0)
	--print("player_score:" .. player_score)
	gui.set_text(self.score_node, tostring(0))
	gui.set_text(self.score_menu, player_score)
	player_score = 0 
	self.score = 0 
	
end 


local function clear_callback(self)
	self.score = 0 
	gui.set_text(self.score_node, "")
end 

local function stats_button(self)
	monarch.show("Stats_Gameboard")
end 

local function finish_callback(self)
	message = {}
	message['text'] = "End game?" 
	
	monarch.show("End_Game" , nil , message )
    end_question = monarch.data("End_Game")
	if end_question == "Yes" then 
		finish_game(score_db) -- save current scores to find winner 
		
	end
	--tweles = find_12s(score_db,0)
	-- save_stats(score_db) -- save stats WIP 
	-- gui.play_particlefx(self.firework_red)
	-- gui.play_particlefx(self.firework_blue)
	-- gui.play_particlefx(self.firework_green) 
	-- gui.play_particlefx(self.firework_yellow)
	-- gui.play_particlefx(self.firework_orange)
	-- gui.play_particlefx(self.firework_purple)
	-- msg.post("main:/winner#winner_box", "Show")
	  
	-- score_db = {}
	-- --score_db[self.date][self.round_num] = {}
	-- gui.set_text(self.score_button, 0)
end 


local function add_callback(self)
	msg.post("main:/add_user#add_user_prompt", "Show")
end 

local function remove_callback(self)
	msg.post("main:/remove_user#remove_user_prompt", "Show")
end 


function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	--monarch.hide('Main_Menu')
	-- init druid 
	self.druid = druid.new(self)
	self.start_time = os.date()
	msg.post(".", "acquire_input_focus")
	-- gui settings 
	self.gray_background_box = gui.get_node("Menu_box")
	self.button1 = gui.get_node("Button1/buttonBody")
	self.button2 = gui.get_node("Button2/buttonBody")
	self.button4 = gui.get_node("Button4/buttonBody")
	self.button5 = gui.get_node("Button5/buttonBody")
	self.button12 = gui.get_node("Button12/buttonBody")
	
	self.okaybutton = gui.get_node("OkayButton/buttonBody")
	self.okay = gui.get_node("OkayButton/buttonBody")
    -- not needed 
	self.Addbutton = gui.get_node("addButton/buttonBody")
	self.Removebutton = gui.get_node("removeButton/buttonBody")
    -- end not needed 
	self.clear_button = gui.get_node("clear_button/buttonBody")
	self.score_menu = gui.get_node("score_text_menu")
	self.username = gui.get_node("username")
	self.round_number_menu = gui.get_node("round_number")	
	self.score_node = gui.get_node("score_text")
	self.stats_button = gui.get_node("stats_label")
	self.end_game_button = gui.get_node("end_game_label")
-- 
-- 	local check_popup =  monarch.data("Game_Board")
-- 	if not next(check_popup) then
-- 		print("nil")
-- 	else 
-- 		if check_popup['answer'] == "Yes" then
-- 			monarch.show("Winner")
-- 		end
-- 	end 

		
	-- fireworks
	self.firework_red = gui.get_node("firework_red")
	self.firework_blue = gui.get_node("firework_blue")
	self.firework_green = gui.get_node("firework_green")
	self.firework_yellow = gui.get_node("firework_yellow")
	self.firework_orange = gui.get_node("firework_orange")
	self.firework_purple = gui.get_node("firework_purple")

	-- score window 
	self.score_button = gui.get_node("score_text_menu")	
	
   -- user vars 
	--self.user1 = "Dad"
	--self.user2 = "Matt"
	--self.active_user = self.user1
	self.round_num = 1
	self.score = 0 
	self.winner = ""
	-- self.user1_score = 0
	-- self.user2_score =0 
	-- self.message = ""
	score_db = {}
	score_db[self.round_num] = {}
--	

	-- buttons 
	self.druid:new_button("Button1/buttonBody", button1_callback)
	self.druid:new_button("Button2/buttonBody", button2_callback)
	self.druid:new_button("Button4/buttonBody", button4_callback)
	self.druid:new_button("Button5/buttonBody", button5_callback)
	self.druid:new_button("Button12/buttonBody", button12_callback)

	self.druid:new_button("OkayButton/buttonBody", okay_callback)
	self.druid:new_button("clear_button/buttonBody", clear_callback)

	self.druid:new_button("addButton/buttonBody", add_callback)
	self.druid:new_button("removeButton/buttonBody", remove_callback)
	self.druid:new_button("end_game_button/buttonBody", finish_callback)
	self.druid:new_button("score_text_menu", score_text_menu)
	--self.druid:new_button("add_user_label", add_callback)
	--self.druid:new_button("remove_user_label", remove_callback)
	self.druid:new_button("end_game_label", finish_callback)
	self.druid:new_button("stats_label", stats_button)
	
	msg.post("#", "show")
	
end 





local function save_data(players)
	local filename = sys.get_save_file("playerfilename", "players")
	
	local path_to_file = sys.get_save_file("6 in a row", "dummy_test")
	print(path_to_file)
	sys.save(filename, players ) 
end



function remove_user(remove_player)
	print("removed user" .. remove_player)
	local load_players = load_users()
	table.remove(load_players)
	save_data(load_players)
end	


function print_users(players)

	for index, data in ipairs(players) do
		print("Player:" .. index .. " " .. data .. " saved...")
	end
	
end

function load_users()
	local filename = sys.get_save_file("playerfilename", "players") -- <1>
	local data = sys.load(filename) 
	return data
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	self.druid:final()
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
	self.druid:on_message(message_id, message, sender)
	if message_id == hash("add_score") then
		score = "score:".. score + message.amount
		gui.set_text(self.score_node, tostring(self.score))
	end

	if message_id == hash("show") then 
		gui.set_enabled(self.button1, true)
		gui.set_enabled(self.button2, true)
		gui.set_enabled(self.button4, true)
		gui.set_enabled(self.button5, true)
		gui.set_enabled(self.button12, true)

		gui.set_enabled(self.gray_background_box, true)

		gui.set_enabled(self.okaybutton, true)
		-- disabled for now 
		gui.set_enabled(self.Addbutton, false)
		gui.set_enabled(self.Removebutton, false)
		gui.set_enabled(self.stats_button, true)
		gui.set_enabled(self.clear_button, true)
		gui.set_enabled(self.score_menu, true)
		gui.set_enabled(self.username, true)
		gui.set_enabled(self.round_number_menu, true)
		gui.set_enabled(self.score_node, true)
		gui.set_enabled(self.end_game_button, true)
		active_players = load_active_players()
		
		local playername_fit = self.druid:new_text("username", active_players[1])
		playername_fit:set_to(active_players[1])
		gui.set_text(self.round_number_menu, "Round:" .. tostring(self.round_num))
	end

	
	if message_id == hash("hide") then 
		gui.set_enabled(self.button1, disable)
		gui.set_enabled(self.button2, disable)
		gui.set_enabled(self.button4, disable)
		gui.set_enabled(self.button5, disable)
		gui.set_enabled(self.button12, disable)
		
		gui.set_enabled(self.gray_background_box, disable)
		gui.set_enabled(self.stats_button, disable)
		gui.set_enabled(self.okaybutton, disable)
		gui.set_enabled(self.Addbutton, disable)
		gui.set_enabled(self.Removebutton, disable)

		gui.set_enabled(self.clear_button, disable)
		gui.set_enabled(self.score_menu, disable)
		gui.set_enabled(self.username, disable)
		gui.set_enabled(self.round_number_menu, disable)
		gui.set_enabled(self.score_node, disable)
		gui.set_enabled(self.end_game_button, disable)
	end
	
	if message_id == hash("get res") then 
		self.window_height = gui.get_height()
		self.window_width = gui.get_width()
		print(tostring(self.window_height) .. "x" .. tostring(self.window_width))
	end 
end

function on_input(self, action_id, action)

   return self.druid:on_input(action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end