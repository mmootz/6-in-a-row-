local score = 0

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	msg.post(".", "acquire_input_focus")
   -- gui settings 
	self.button1 = gui.get_node("Button1/buttonBody")
	self.button2 = gui.get_node("Button2/buttonBody")
	self.button4 = gui.get_node("Button4/buttonBody")
	self.button5 = gui.get_node("Button5/buttonBody")
	self.button12 = gui.get_node("Button12/buttonBody")
	self.okaybutton = gui.get_node("OkayButton/buttonBody")
	self.score_menu = gui.get_node("score_text_menu")
	self.username = gui.get_node("username")
	self.round_number_menu = gui.get_node("round_number")	
	self.score_node = gui.get_node("score_text")
	-- win gui settings 
	self.winner_title = gui.get_node("winner_box")
	self.winner_body = gui.get_node("winner_text")
	self.winner_body_button = gui.get_node("winner_okay_button/buttonBody")
	self.winner_body_text = gui.get_node("winner_text_user")
	self.end_game_button = gui.get_node("end_game_button/buttonBody")
	self.firework_red = gui.get_node("firework_red")
	self.firework_blue = gui.get_node("firework_blue")
	self.firework_green = gui.get_node("firework_green")
	self.firework_yellow = gui.get_node("firework_yellow")
	self.firework_orange = gui.get_node("firework_orange")
	self.firework_purple = gui.get_node("firework_purple")
	gui.set_enabled(self.winner_title, false)
	gui.set_enabled(self.winner_body, false)
	gui.set_enabled(self.winner_body_button, false)
	gui.set_enabled(self.winner_body_text, false)
	
   -- user vars 
	self.user1 = "Dad"
	self.user2 = "Matt"
	self.active_user = self.user1
	self.round_num = 1
	self.score = 0
	self.winner = ""
	self.user1_score = 0
	self.user2_score =0 
	game = {}
	gui.set_text(self.username, self.active_user)
	gui.set_text(self.round_number_menu, "Round:" .. tostring(self.round_num))
	
end

local function save_data(data)
	local filename = sys.get_save_file("sys_save_load", "data")
	print("save:" .. data)
	sys.save(filename, { round = data }) 
end

local function add_user(txt)
	print("add user:" .. txt)
	save_data(txt)
end 

local function add_score(score,num)	
	total = score + num
	return total 
end 


local function load_users()
	local filename = sys.get_save_file("sys_save_load", "data") -- <1>
	local data = sys.load(filename) 
	return data.round 
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
	if message_id == hash("add_score") then
		score = score + message.amount
		print(tostring(score))
		gui.set_text(self.score_node, tostring(self.score))
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	if action.pressed and gui.pick_node(self.button1, action.x, action.y) then
		gui.play_flipbook(self.button1, hash("Button_Pressed"))
		self.score = add_score(self.score, 2)
		--save_data(tostring(self.round_num)..":"..tostring(self.score)..":"..tostring(self.active_user))
		
		gui.set_text(self.score_node, tostring(self.score))
	elseif action.released and gui.pick_node(self.button1, action.x, action.y) then
			print("unpressed")
			gui.play_flipbook(self.button1, hash("Button_released"))
	--    msg.post(".", "acquire_input_focus")
	end 

	if action.pressed and gui.pick_node(self.button2, action.x, action.y) then
		gui.play_flipbook(self.button2, hash("Button_Pressed"))
		self.score = add_score(self.score, 3)
		local test = load_users()
		print(test)
		gui.set_text(self.score_node, tostring(self.score))
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.button2, action.x, action.y) then
		gui.play_flipbook(self.button2, hash("Button_released"))
		--    msg.post(".", "acquire_input_focus")
	end

	if action.pressed and gui.pick_node(self.button4, action.x, action.y) then
		gui.play_flipbook(self.button4, hash("Button_Pressed"))
		self.score = add_score(self.score, 4)
		gui.set_text(self.score_node, tostring(self.score))
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.button4, action.x, action.y) then
		gui.play_flipbook(self.button4, hash("Button_released"))
		--    msg.post(".", "acquire_input_focus")
	end

	if action.pressed and gui.pick_node(self.button5, action.x, action.y) then
		gui.play_flipbook(self.button5, hash("Button_Pressed"))
		self.score = add_score(self.score, 5)
		gui.set_text(self.score_node, tostring(self.score))
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.button5, action.x, action.y) then
		gui.play_flipbook(self.button5, hash("Button_released"))
		--    msg.post(".", "acquire_input_focus")
	end

	if action.pressed and gui.pick_node(self.button12, action.x, action.y) then
		gui.play_flipbook(self.button12, hash("Button_Pressed"))
		self.score = add_score(self.score, 12)
		-- play animation here once figured out
		gui.play_particlefx(self.firework_red)
		gui.play_particlefx(self.firework_blue)
		gui.play_particlefx(self.firework_green) 
		gui.play_particlefx(self.firework_yellow)
		gui.play_particlefx(self.firework_orange)
		gui.play_particlefx(self.firework_purple) 
		gui.set_text(self.score_node, tostring(self.score))
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.button12, action.x, action.y) then
		gui.play_flipbook(self.button12, hash("Button_released"))
		gui.stop_particlefx(self.firework_red)
		gui.stop_particlefx(self.firework_blue)
		gui.stop_particlefx(self.firework_green)
		gui.stop_particlefx(self.firework_yellow)
		gui.stop_particlefx(self.firework_orange)
		gui.stop_particlefx(self.firework_purple)
		--    msg.post(".", "acquire_input_focus")
	end
	
	if action.pressed and gui.pick_node(self.okaybutton, action.x, action.y) then
		print("okayButton")
		gui.play_flipbook(self.okaybutton, hash("Button_Pressed"))
		--gui.set_text(self.score_menu, "score:"..tostring(self.score))
		--gui.set_text(self.score_node, "0")
		-- if Dad user switch to Matt 
		if self.active_user == self.user1 then 
			-- switch to Matt 
			self.active_user = self.user2
			gui.set_text(self.username, self.active_user)
			-- gui.set_text(self.username, )
			-- set Dad score to current score  
			self.user1_score = self.score + self.user1_score
			-- set user score on menu 
			game[self.round.num] = {}
			game[self.round.num][self.user1] = self.user1_score
			gui.set_text(self.score_menu, tostring(self.user2_score))
			-- reset score to 0 			
			self.score = 0
			gui.set_text(self.score_node, "0")
			-- update the round menu here after we set to zero 
			self.round_num = self.round_num + 1 
			gui.set_text(self.round_number_menu, "Round:" .. tostring(self.round_num))
			 
		-- Matt User 
		elseif self.active_user == self.user2 then
			-- switch to Dad 
			self.active_user = self.user1
			-- set Matt score to current score
			self.user2_score = self.score + self.user2_score
			-- add user to score menu 
			game[self.round.num] = {}
			game[self.round.num][self.user1] = self.user1_score
			gui.set_text(self.score_menu, tostring(self.user1_score))
			gui.set_text(self.username, self.active_user)
			self.score = 0
			gui.set_text(self.score_node, "0")
			self.round_num = self.round_num + 1 
			gui.set_text(self.round_number_menu, "Round:" .. tostring(self.round_num))
		end
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.okaybutton, action.x, action.y) then
		print("unpressed")
		gui.play_flipbook(self.okaybutton, hash("Button_released"))
		--    msg.post(".", "acquire_input_focus")
	end
	
	if action.pressed and gui.pick_node(self.end_game_button, action.x, action.y) then
		gui.play_flipbook(self.end_game_button, hash("Button_Pressed"))	
		print(tostring(self.score_user1))
		if self.user1_score > self.user2_score then
			self.winner = self.user1
			self.win_score = self.user1_score
		elseif self.user1_score < self.user2_score then
			self.winner = self.user2
			self.win_score = self.user2_score
		end 

		gui.set_enabled(self.winner_title, true)
		gui.set_enabled(self.winner_body, true)
		gui.set_enabled(self.winner_body_button, true)
		gui.set_enabled(self.winner_body_text, true)
		gui.set_text(self.winner_body_text, "User: " .. self.winner .. " score:" .. tostring(self.win_score))
		-- play animation here once figured out 
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.end_game_button, action.x, action.y) then
		gui.play_flipbook(self.end_game_button, hash("Button_released"))
		
		--    msg.post(".", "acquire_input_focus")
	end

	if action.pressed and gui.pick_node(self.winner_body_button, action.x, action.y) then
		gui.play_flipbook(self.winner_body_button, hash("Button_Pressed"))
		gui.set_enabled(self.winner_title, false)
		gui.set_enabled(self.winner_body, false)
		gui.set_enabled(self.winner_body_button, false)
		gui.set_enabled(self.winner_body_text, false)
		self.user1_score = 0 
		self.user2_score = 0
		self.score = 0
		self.round_num = 1
		
		-- play animation here once figured out 
		--msg.post("scoreboard#gui", "add_score", {amount = score})
	elseif action.released and gui.pick_node(self.winner_body_button, action.x, action.y) then
		gui.play_flipbook(self.winner_body_button, hash("Button_released"))
		--    msg.post(".", "acquire_input_focus")
	end
	
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
